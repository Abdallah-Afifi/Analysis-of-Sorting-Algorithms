# Analysis-of-Sorting-Algorithms

# Development Plan

Define the project requirements: Read and understand the project requirements, the sorting algorithms that need to be implemented, and the method of verification.

Design the system: Develop a plan for the software system. This includes designing the architecture, creating the UML diagrams, and creating class structure and header files.

Generate Random Permutation Arrays (RPA): Implement a function to generate RPA for the first N integers in the array. This should ensure that all integers from 1 to N are present but in a random order, with no integer missing and no integer duplicated.

Implement Sorting Algorithms: Implement the selection sort, insertion sort, merge sort, quick sort with the first element as the pivot, and randomized quick sort. Add counters to each algorithm to count the number of element comparisons.

Count the Number of Array Element Comparisons: Introduce a counter inside the code to count the number of array element comparisons done by the algorithm at the end of the sorting process.

Conduct Experiments: Conduct 6 different experiments, using 6 different array sizes (N = 1000, 2000, 3000, 5000, 7000, 10000), for each of the 5 sorting algorithms. For each experiment, find Texp(N) (the number of array element comparisons that you counted as done by the algorithm for each of the 6 array sizes N).

Compare Experimental and Expected Results: Compare the experimental results with those expected Tmodel(N) from the mathematical modeling of the algorithm. Show the comparison in tables and graphical form.

Analyze the Results: Provide an analysis of the results in comparison with those expected from the mathematical modeling of the algorithms. Use Tmodel(N) for the tested algorithms, given in Appendix 3.

Develop the Final Report: Develop the final report of the project in the format provided. Include all UML diagrams, class structure and class header files, source code, and a small readme with your names, IDs, and sections you are registered in.

Milestone #1 (April 24th): Deliver all UML diagrams, class structure and class header
files for your project, as well as a small readme with your names, IDs, and sections you are
registered in.

Milestone #2 (May 13th): You are to deliver a final report of the
project as in the attached format, as well as all source code.


# Objectives

Abdallah:

Implement Selection Sort algorithm and add counters to count the number of array element comparisons.
Conduct experiments to find Texp(N) for each of the 6 array sizes N = 1000, 2000, 3000, 5000, 7000, 10000 for Selection Sort.
Implement Quick Sort algorithm and add counters to count the number of array element comparisons.
Conduct experiments to find Texp(N) for each of the 6 array sizes N = 1000, 2000, 3000, 5000, 7000, 10000 for Quick Sort.
Compare experimental results with those expected Tmodel(N) from the mathematical modeling of the algorithm.


Hana:
Abstract Sort class with all the basic functions.
Implement Insertion Sort algorithm and add counters to count the number of array element comparisons.
Conduct experiments to find Texp(N) for each of the 6 array sizes N = 1000, 2000, 3000, 5000, 7000, 10000 for Insertion Sort.
Implement Quick Sort algorithm and add counters to count the number of array element comparisons.
Conduct experiments to find Texp(N) for each of the 6 array sizes N = 1000, 2000, 3000, 5000, 7000, 10000 for Quick Sort.
Compare experimental results with those expected Tmodel(N) from the mathematical modeling of the algorithm.

Adham:

Implement Merge Sort algorithm and add counters to count the number of array element comparisons.
Conduct experiments to find Texp(N) for each of the 6 array sizes N = 1000, 2000, 3000, 5000, 7000, 10000 for Merge Sort.
Implement Quick Sort algorithm and add counters to count the number of array element comparisons.
Conduct experiments to find Texp(N) for each of the 6 array sizes N = 1000, 2000, 3000, 5000, 7000, 10000 for Quick Sort.
Compare experimental results with those expected Tmodel(N) from the mathematical modeling of the algorithm.

All programmers will need to work together to generate the input (Random Permutation Arrays) for the sorting algorithms using the method given in Appendix 1 and store them in an array of size (N+1), starting from location 1 and ending at location N. Leave location (0) unused. Additionally, all programmers will need to provide an analysis of the results in comparison with those expected from the mathematical modeling of the algorithms.

# Timeline (For All)

By the end of Monday 10/4:

Design the architecture, creating the UML diagrams, and creating class structure and header files.
Implement the selection sort, insertion sort, merge sort, quick sort with the first element as the pivot, and randomized quick sort. Add counters to each algorithm to count the number of element comparisons.
